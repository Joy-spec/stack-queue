# recursion
recursion是递归的意思
## 尾递归
## 递归改非递归
 递归中出现函数自己调用自己的现象，函数的调用是通过栈实现的，因可以自己直接使用栈来将递归变为非递归  
以汉诺塔为例，(将圆盘从柱子x通过柱子y搬运到柱子z上)  
  递归的写法是：
```
	if(n==1) {
		cout<<x<<"->"<<z<<endl;	
	}
	else{
  //分解成了两个子问题+一步操作
		solveHanoi(n-1,x,z,y);
		cout<<x<<"->"<<z<<endl;
		solveHanoi(n-1,y,x,z);
	}
```
  其实就是将一个问题分成了两个子问题。如果子问题能够直接解决（即是最小子问题），则直接解决，否则子问题会再分解成子问题。  
非递归的思路就是，在栈中保存当前需要解决的问题。  
  一般的方法如下：
  ```
  总问题入栈
  while（栈不为空）{
    出栈；
    如果出栈的问题已经是最小问题，则直接解决
    否则，将该问题划分成子问题，子问题进栈
    }
  ```
  汉诺塔的非递归写法：
```
	stack<node> s;
	s.push(node(n,x,y,z));//总问题进栈
	while(!s.empty()){//循环开始
    //出栈一个问题
		node tmp=s.top();
		s.pop();
		if(tmp.n==1){
			cout<<tmp.x<<"->"<<tmp.z<<endl;
		} 
		else{
			//注意这里的压栈顺序是与递归调用的顺序恰好相反的
			//因为栈是后进先出，因此递归时先执行的要后入栈 
			s.push(node(tmp.n-1,tmp.y,tmp.x,tmp.z));
			//注意这里，不像递归调用中直接输出了x->z
			//这时因为，子问题是在出栈的时候解决的，如果这里直接写成x->z意味着这个操作先于两个子问题的解决发生
			//而事实上这个操作应该夹在两个子问题之间解决 
			s.push(node(1,tmp.x,tmp.y,tmp.z));
			s.push(node(tmp.n-1,tmp.x,tmp.z,tmp.y));
		}
	}//循环结束
```
  - 需要注意的是，子问题入栈的顺序与递归中分解出的子问题的顺序正好是相反的。递归中将A分解成了B，C两个子问题，正确顺序是先解决B然后再解决C。那么使用非递归入栈的时候应该C先入栈，B在入栈，因为后入栈的问题会被先解决。
  - 栈能解决递归的原因：栈的后进先出配合问题的分解，能够保证彻底解决了一个子问题之后才能解决后一个问题
  - 在汉诺塔的非递归实现中，可以看到将一个大问题分解成了三个子问题而不是像递归中分解成两个子问题和一步操作。这是因为，子问题的解决发生在出栈时候，且这个一步操作需要在第一个子问题解决之后执行。只有把这个一步操作也当作栈中的一个子问题帧才能保证正确的执行顺序
  
  
